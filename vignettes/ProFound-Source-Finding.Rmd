---
title: "ProFound-Source-Finding"
author: "Aaron Robotham"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ProFound: Source Finding}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The **ProFit** R package comes with the **ProFound** source finding and image utilites suite. This covers the following functions:

### Very High Level

- profitProFound: Source finder and CoG growing utility (this is what we refer to as ProFound elsewhere, as a short-hand)

### High Level

- profitMakeSegim: Watershed image segmentation
- profitMakeSkyGrid: Calculate smoothed (e.g. bicubic) sky maps
- profitSkyEst: Sky estimator using circular annuli (robust to bright sources)


### Mid Level

- profitMakeSegimExpand: Segmentation map expansion
- profitMakeSegimDilate: Segmentation map dilation
- profitSegimStats: Image segmentation statistics (e.g. flux, apertures etc)
- profitSegimPlots: Image segmentation plots
- profitMakeSkyMap: Calculate coarse sky maps
- profitSkyEstLoc: Local sky estimator using source clipping
- profitGainEst: Estimate image gain

### Low Level

- profitGainConvert: Update gain values when changing zero-points
- profitImBlur: Fast image blur
- profitImDiff: Fast image difference
- profitImGrad: Fast image gradients
- profitFlux2Mag: Convert from flux to magnitude
- profitMag2Flux: Convert from magnitude to flux
- profitFlux2SB: Convert from flux to surface brightness
- profitSB2Flux: Convert from surface brightness to flux
- profitMag2Mu: Convert from magnitude to central surface brightness
- profitMag2Mu: Convert from central surface brightness to magnitude
- profitInterp2d: Image interpolation

## ProFound

The **profitProFound** function might be the only function many people need to use in order to extract photometry from a target image. In brief, in fully automatic mode using default option, it does the following things:

- Makes a rough sky map
- Using this rough sky map, makes an initial segmentation image
- Using this segmentation image, makes a better sky map
- Using this better sky map, extracts basic photometric properties
- Using the current segmentation image it starts to dilate a re-measure photometric properties for the image segments (this stage iterates for 6 times by default)
- Using the iterative dilation statistics, every object is checked for flux convergence
- A final segmentation image is made, combining the segments when each source has converged in flux
- Using this final segmentation image, make a final sky map
- Using the final segmentation image and final sky map, computes final photometric properties
- Returns a list containing input image pixel matched **segim**, **objects**, **sky** and **skyRMS**, as well as the **segstats** data-frame of photometric properties for every detected source

Load some libraries:

```{r}
library(ProFit)
library(FITSio)
```

First read in some data.

```{r}
image=readFITS(system.file("extdata", 'VIKING/mystery_VIKING_Z.fits',package="ProFit"))
```

Give it a quick look:

```{r, fig.width=5, fig.height=5}
magimageWCS(image)
```

A basic example of the lower level **profitMakeSegim** versus the higher level **profitProFound**:

```{r, fig.width=5, fig.height=5}
out_segim=segim=profitMakeSegim(image$imDat, skycut=1.5, magzero=30, pixscale=0.339,
header=image$hdr, plot=TRUE)
out_profound=profitProFound(image$imDat, skycut=1.5, magzero=30, pixscale=0.339, header=image$hdr, verbose=TRUE, plot=TRUE)
```

Notice in the two outputs (the first being **profitMakeSegim**, the second being **profitProFound**) that some segment have converged quickly (i.e. not grown much) but others have expanded a lot in order to capture all the flux present. **profitProFound** in default mode with modern survey imaging data tends to extract very close to a true total magnitude, without too much error introduced by sky noise (a consequence of over-growing apertures).

Because it was run in verbose mode, the major **profitProFound** steps mentioned above were printed out. For large images (a few thousand by a few thousand pixels plus) this is useful since it can take a few minutes to run with all the bells and whistles turned on, and it is nice to see it making progress. Note for more than a couple of hundred sources, you almost certainly do not want to plot the output, since this will be slow.


Note because we parsed **profitProFound** a header we have RA and Dec coordinates in the photometric properties data-frame. We also parsed the appropriate magnitude zero-point and pixel scale so the mag properties are correctly scaled, and R/R50/R90 are in arc-seconds rather than pixels. It is is worth checking the output:
 
```{r}
out_profound$segstats[1:10,]
```

Next we will check the before and after photometry for the brightest 40 sources (the lists differ a bit in detail due to the different sky estimation routines used):

```{r, fig.width=5, fig.height=5}
magplot(out_segim$segstats[1:40,c("R50", "SB_N90")], col=hsv(magmap(out_segim$segstats$axrat, flip=TRUE)$map), log='x', xlim=c(0.4,5), ylim=c(22,25), grid=TRUE, xlab='R50 / asec', ylab='mag / asec^2')
points(out_profound$segstats[1:40,c("R50", "SB_N90")], col=hsv(magmap(out_segim$segstats$axrat, flip=TRUE)$map), pch=16)
arrows(out_segim$segstats$R50[1:40], out_segim$segstats$SB_N90[1:40], out_profound$segstats$R50[1:40], out_profound$segstats$SB_N90[1:40], col='lightgrey', length=0)
rect(0.9, 23.5, 1.3, 24.3)
legend('bottomleft', legend=c('profitProFound', 'profitMakeSegim'), pch=c(16,1))
magbar('topright', title='Axrat', titleshift=1)

magplot(out_segim$segstats[1:40,c("R50", "con")], col=hsv(magmap(out_segim$segstats$axrat, flip=TRUE)$map), log='x', xlim=c(0.4,5), ylim=c(0,1), grid=TRUE, xlab='R50 / asec', ylab='Concentration')
points(out_profound$segstats[1:40,c("R50", "con")], col=hsv(magmap(out_segim$segstats$axrat, flip=TRUE)$map), pch=16)
arrows(out_segim$segstats$R50[1:40], out_segim$segstats$con[1:40], out_profound$segstats$R50[1:40], out_profound$segstats$con[1:40], col='lightgrey', length=0)
rect(0.9, 0.4, 1.3, 0.6)
legend('bottomleft', legend=c('profitProFound', 'profitMakeSegim'), pch=c(16,1))
magbar('topright', title='Axrat', titleshift=1)

magplot(out_segim$segstats[1:40,c("R50", "mag")], col=hsv(magmap(out_segim$segstats$axrat, flip=TRUE)$map), log='x', xlim=c(0.4,5), ylim=c(17,24), grid=TRUE, xlab='R50 / asec', ylab='Mag')
points(out_profound$segstats[1:40,c("R50", "mag")], col=hsv(magmap(out_segim$segstats$axrat, flip=TRUE)$map), pch=16)
arrows(out_segim$segstats$R50[1:40], out_segim$segstats$mag[1:40], out_profound$segstats$R50[1:40], out_profound$segstats$mag[1:40], col='lightgrey', length=0)
rect(0.9, 20, 1.3, 22)
legend('bottomleft', legend=c('profitProFound', 'profitMakeSegim'), pch=c(16,1))
magbar('topright', title='Axrat', titleshift=1)
```

It is notable that low surface brightness objects are seen to systematically grow when processing the image with **profitProFound**. The box represents the location of likely stars, where redder objects are more circular sources. It is clear that **profitProFound** moves stars onto a more uniform value of R50 (remember for a Gaussian PSF FWHM=2*R50).

The **profitProFound** function also returns a sky and sky RMS image matched to the input image:

```{r, fig.width=5, fig.height=4}
maghist(out_profound$sky, xlab='Sky')
maghist(out_profound$skyRMS, xlab='Sky RMS')
```

```{r, fig.width=5, fig.height=5}
magimageWCS(image$imDat, image$hdr)
magimageWCS(out_profound$sky, image$hdr)
magimageWCS(out_profound$skyRMS, image$hdr)
```

The background mask we used here (the default 100x100 option) looks to be pretty good, with not much correlation between the image and the sky map. However, even with a slightly too small sky grid the photometric outputs should be mostly pretty robust- differing by at worst a couple of counts per pixel. This is much less than the typical sky RMS (roughly 9 throughout).

```{r, fig.width=5, fig.height=4}
maghist(out_profound$segstats[,'N100']/out_profound$segstats[,'flux'], xlab=' Worst case fraction error')
```

In summary, you probably want to use **profitProFound**, unless you really know what you are doing and are feeling a bit adventurous!

## Advanced Usage

The way **ProFound** handles the various inputs allows for great flexibility and power. AS an example, it is fairly trivial to run it in a mode where you can extract multiband photometry in pixel matched data. AS a pseudo code example imagine you have 3 pixel matched 2k*2K J/H/K band images with the same magnitude zero points. You can use the objects detected in, say, the K band to extract photometry in the others:

```R
pro_det_K=profitProFound(image=Kim)
```

We can then extract matching photometry. Note that in practice pro_K_tot_fix = pro_det_K (since the K band was our detection band already), but we psuedo re-run it for clarity.

```R
pro_J_tot_fix=profitProFound(image=Jim, segim=pro_det_K$segim, iters=0)
pro_H_tot_fix=profitProFound(image=Him, segim=pro_det_K$segim, iters=0)
pro_K_tot_fix=profitProFound(image=Kim, segim=pro_det_K$segim, iters=0)
```

In the above this would extract close to total photometry given the K-band object extraction. You often find better colours running with the high surface brightness non-dilated segmentation map, which is also returned by **ProFound**. In this case you would need to re-run the K too. Notice we also pass the **objects** matrix to ProFound. This ensures a better sky estimation, since we are now using the brighter inner part of detected objects to extract colour photometry, but we want to know the location of the full object to obtain a good sky estimate.

```R
pro_J_col_fix=profitProFound(image=Jim, segim=pro_det_K$segim_orig, objects=pro_det_K$objects, iters=0)
pro_H_col_fix=profitProFound(image=Him, segim=pro_det_K$segim_orig, objects=pro_det_K$objects, iters=0)
pro_K_col_fix=profitProFound(image=Kim, segim=pro_det_K$segim_orig, objects=pro_det_K$objects, iters=0)
```

A third option is to allow each target band to dynamically dilate based on the original segmentation map. The might help in situations where the target image PSFs are quite mismatched. The dynamic dilation will ensure close to total magnitudes regardless of the differing PSFs. Note that in practice pro_K_tot_dil = pro_det_K (since the K band was our detection band already), but we psuedo re-run it for clarity.

```R
pro_J_tot_dil=profitProFound(image=Jim, segim=pro_det_K$segim_orig, objects=pro_det_K$objects)
pro_H_tot_dil=profitProFound(image=Him, segim=pro_det_K$segim_orig, objects=pro_det_K$objects)
pro_K_tot_dil=profitProFound(image=Kim, segim=pro_det_K$segim_orig, objects=pro_det_K$objects)
```

Given these outputs a photometrically driven user can create a S/N stacked image weighted using the inverse of ${sky_{RMS}}^2$. The reason we weight it this way is you actually want to weight by exposure time, which correlates with inverse variance (traditional Source Extractor weight maps are inverse variance for this reason), which is $1/{sky_{RMS}}^2$. To convince yourself consider you have 8 exposures with sky RMS equal to 16 originally: 4 you combine, so the sky RMS becomes $\sqrt{\frac{1}{16^2}+\frac{1}{16^2}+\frac{1}{16^2}+\frac{1}{16^2}}=\sqrt{\frac{4}{16^2}}=8$. Now later on you want to combine the 5 images you have. Clearly the optimal weighting you can possibly get will be $\sqrt{\frac{8}{16^2}}=\frac{8}{\sqrt{2}}=5.65$ (the direct stack of the original 8 images). With our already stacked image added to our 4 others we can achieve the same S/N by weighting our stacks by the inverse variance: $\sqrt{\frac{1}{16^2}+\frac{1}{16^2}+\frac{1}{16^2}+\frac{1}{16^2}+\frac{1}{8^2}}=\sqrt{\frac{4}{16^2}+\frac{1}{8^2}}=\frac{8}{\sqrt{2}}=5.65$.

Below we do this with our pseudo images, the only caveat being we divide by 3 to maintain our magnitude zero-point. Why? Well, consider what you would do if these 3 images were in the same band for the same exposure time and had the same measured sky RMS- our optimal stacking method is to just add them together, but this would increase the implied flux by a factor of 3, so dividing by 3 means we have the same magnitude zero-point but our stacked image now has a reduced sky RMS when we measure it.

```R
stack=matrix(0,2000,2000) #Since our images are assumed to be 2k*2k
stack=stack+(Jim-pro_J_tot_dil$sky)/(pro_J_tot_dil$skyRMS^2)
stack=stack+(Him-pro_H_tot_dil$sky)/(pro_H_tot_dil$skyRMS^2)
stack=stack+(Kim-pro_K_tot_dil$sky)/(pro_K_tot_dil$skyRMS^2)
sky_stack=(pro_J_tot_dil$skyRMS^2 + pro_H_tot_dil$skyRMS^2 + pro_K_tot_dil$skyRMS^2)/3
stack=stack*sky_stack
```

We can now make a new detection based on the S/N stacked images!

```R
pro_det_stack=profitProFound(stack)
```

We can now effectively re-run all the above, but using pro_det_stack where before we had pro_det_K.
