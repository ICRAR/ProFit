# Convenient function to flatten a list into another list and
# avoid coercion into a single type (usually numeric/double)
.renquote = function(l) if (is.vector(l) && (length(l) > 1 || is.list(l))) lapply(l, .renquote) else enquote(l)
.flattenlist = function(ml) lapply(unlist(.renquote(ml)), eval)
.rrelist = function(flesh, skeleton=attr(flesh, "skeleton")){
  index = 1
  result = skeleton
  for (i in 1:length(skeleton)) {
    size = length(unlist(result[[i]]))
    if(is.list(result[[i]])) {
      result[[i]] = .rrelist(flesh[index:(index + size - 1)], result[[i]])
    } else if(size >1) {
      result[[i]] = relist(flesh[index:(index + size - 1)], result[[i]])
    } else {
      result[[i]] = flesh[[index]]
    }
    index <- index + size
  }
  result
}

profitLikeModel=function(parm, Data, makeplots=FALSE, serscomp='all', pscomp='all', rough=FALSE,
  cmap = rev(colorRampPalette(brewer.pal(9,'RdYlBu'))(200)), errcmap=cmap, plotchisq=FALSE) {
  if(class(Data)!='profit.data'){stop("The Data must be of class profit.data, as generated by the profitSetupData function!")}
  usecovar = FALSE
  finesample = 1L
  if(length(Data$finesample)>0) finesample = Data$finesample
  profitCheckFinesample(finesample)
  stopifnot(Data$like.func %in% c('norm', 't', 'chisq'))
  
  fitIDs=which(unlist(Data$tofit))
  parm=parm[1:length(fitIDs)]
  paramsinit=.flattenlist(Data$model)
  paramsnew=paramsinit
  paramsnew[fitIDs]=parm
  
  intervals = .flattenlist(Data$intervals)
  for(i in fitIDs){
    paramsnew[i]=intervals[[i]](paramsnew[[i]])
  }
  parm=paramsnew[fitIDs]
  
  inheritIDs=which(is.na(.flattenlist(Data$tofit)))
  paramsnew[inheritIDs]=paramsnew[inheritIDs-1]
  
  priors = .flattenlist(Data$priors)
  priorsum=0
  for(i in fitIDs){
    priorsum=priorsum+priors[[i]](paramsinit[[i]]-paramsnew[[i]])
  }
  
  # Flatten or unlist?
  tounlogIDs=which(unlist(Data$tolog) & unlist(Data$tofit))
  for(i in tounlogIDs){
    paramsnew[i]=10^paramsnew[[i]]
  }
  
  paramsnew=.rrelist(paramsnew,Data$model)
  
  img = Data$image
  sigimg = Data$sigma
  
  skylevel = 0
  if(length(Data$skylevel) > 0) skylevel = Data$skylevel
  fit = length(Data$tofit) > 0
  fitsky = fit && !is.null(Data$tofit$sky) && any(unlist(Data$tofit$sky))
  if(fitsky) {
    skylevel = paramsnew$sky$bg
  }
  
  if(Data$fitpsf) {
    psf = profitMakePointSource(model=model$psf, finesample = finesample) 
  } else {
    psf = Data$psf
  }
  
  if(Data$usecalcregion){
    model = profitMakeModel(modellist=paramsnew, magzero = Data$magzero, psf=Data$psf, dim=Data$imagedim, 
      serscomp=serscomp, pscomp=pscomp, rough=rough, calcregion=Data$calcregion, docalcregion=Data$usecalcregion,
      magmu=Data$magmu,finesample=finesample, convopt=Data$convopt)
  }else{
    model = profitMakeModel(modellist=paramsnew, magzero = Data$magzero, psf=Data$psf, dim=Data$imagedim, 
      serscomp=serscomp, pscomp=pscomp, rough=rough, magmu=Data$magmu, finesample=finesample, convopt=Data$convopt)
  }
  
  if(any(Data$region)) {
    cutim=img[Data$region]
    cutmod=model$z[Data$region]
    cutsig=sigimg[Data$region] 
  } else {
    cutim=img
    cutmod=model$z
  }
  ndata = length(cutim)
  
  cutsig=(cutim-cutmod)/cutsig
  vardata = var(cutsig)
  dof=2*vardata/(vardata-1)
  dof=interval(dof,0,Inf)
  if(Data$like.func=="norm"){
    LL=sum(dnorm(cutsig, log=TRUE))
  } else if(Data$like.func=="chisq") {
    LL=dchisq(sum(cutsig^2), ndata, log=TRUE)
  } else if(Data$like.func=="t") {
    LL=sum(dt(cutsig,dof,log=TRUE))
  } else if(Data$like.func=="pois") {
    scale=sqrt(median(abs(cutim/cutsig)))
    LL=sum(dpois(ceiling(cutim/scale),cutmod/scale,log=T))
  } else {
    stop(paste0("Error: unknown likelihood function: '",Data$like.func,"'"))
  }
  
  if(makeplots){
    profitMakePlots(img-skylevel,model$z-skylevel,Data$region, sigimg, cmap=cmap, errcmap=errcmap,plotchisq=plotchisq)
  }
  
  LP=as.numeric(LL+priorsum)
  parm = unlist(parm)
  if(Data$verbose){print(c(parm,LP))}
  if(Data$algo.func=='') return(list(model=model,psf=psf))
  if(Data$algo.func=='optim' | Data$algo.func=='CMA'){out=LP}
  if(Data$algo.func=='LA' | Data$algo.func=='LD'){out=list(LP=LP,Dev=-2*LL,
    Monitor=c(LL=LL,LP=LP,dof=dof),yhat=1,parm=parm)}
  return(out)
}