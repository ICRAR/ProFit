# Convenient function to flatten a list into another list and
# avoid coercion into a single type (usually numeric/double)
renquote <- function(l) if (is.vector(l) && (length(l) > 1 || is.list(l))) lapply(l, renquote) else enquote(l)
flattenlist <- function(ml) lapply(unlist(renquote(ml)), eval)
rrelist <- function(flesh, skeleton=attr(flesh, "skeleton"))
{
  index <- 1
  result <- skeleton
  for (i in 1:length(skeleton))
  {
    size <- length(unlist(result[[i]]))
    if(is.list(result[[i]]))
    {
      result[[i]] <- rrelist(flesh[index:(index + size - 1)], result[[i]])
    }
    else if(size >1)
    {
      result[[i]] <- relist(flesh[index:(index + size - 1)], result[[i]])
    }
    else
    {
      result[[i]] <- flesh[[index]]
    }
    index <- index + size
  }
  result
}

profitLikeModel=function(parm, Data, makeplots=FALSE, serscomp='all', psfcomp='all', rough=FALSE, usedt=FALSE, 
    cmap = rev(rainbow(1e3,end=2/3)), errcmap=cmap){
    if(class(Data)!='profit.data'){stop("The Data must be of class profit.data, as generated by the profitSetupData function!")}
    usecovar = FALSE
    if(length(Data$usecovar)>0) usecovar = Data$usecovar
    if(length(Data$finesample)>0) finesample = Data$finesample
    stopifnot(is.integer(finesample) && finesample >= 1L)
    tofinesample = finesample > 1L
    
    fitIDs=which(unlist(Data$tofit))
    parm=parm[1:length(fitIDs)]
    paramsinit=flattenlist(Data$model)
    paramsnew=paramsinit
    paramsnew[fitIDs]=parm
    
    intervals = flattenlist(Data$intervals)
    for(i in fitIDs){
      paramsnew[i]=intervals[[i]](paramsnew[[i]])
    }
    parm=paramsnew[fitIDs]
    
    inheritIDs=which(is.na(flattenlist(Data$tofit)))
    paramsnew[inheritIDs]=paramsnew[inheritIDs-1]
    
    priors = flattenlist(Data$priors)
    priorsum=0
    for(i in fitIDs){
      priorsum=priorsum+priors[[i]](paramsinit[[i]]-paramsnew[[i]])
    }
    
    # Flatten or unlist?
    tounlogIDs=which(unlist(Data$tolog) & unlist(Data$tofit))
    for(i in tounlogIDs){
      paramsnew[i]=10^paramsnew[[i]]
    }
    
    paramsnew=rrelist(paramsnew,Data$model)
    
    img = Data$image
    sigimg = Data$sigma
    psfarea = 0
    
    skylevel = 0
    if(length(Data$skylevel) > 0) skylevel = Data$skylevel
    fit = length(Data$tofit) > 0
    fitsky = fit && !is.null(Data$tofit$sky) && any(unlist(Data$tofit$sky))
    if(fitsky)
    {
      skylevel = paramsnew$sky$bg
    }
    
    if(Data$fitpsf)
    {
      psf = profitMakeGaussianPS(model=model$psf, finesample = finesample) 
      
      psfarea = pi*(paramsnew$psf$hwhm)^2*paramsnew$psf$axrat;
      if(!is.null(Data$psfarea) && is.numeric(Data$psfarea)) psfarea = Data$psfarea
    }
    else
    {
      psf = Data$psf
      if(!is.null(Data$psfarea) && is.numeric(Data$psfarea)) psfarea = Data$psfarea
    }
    
    if(usecovar)
    {
      model = profitMakeModel(model=paramsnew, magzero = Data$magzero, psf=psf, dim=Data$imagedim,
        serscomp=serscomp,psfcomp=psfcomp,rough=rough, estdeconvcovar=TRUE, gain = Data$gain,
        finesample=finesample)
      padxy = dim(model$z)
      padimg = matrix(0,padxy[1],padxy[2])
      padsigma = padimg
      padimg[model$xcrop,model$ycrop] = img
      padsigma[model$xcrop,model$ycrop] = sigimg
      
      #chi = (Data$image - model$z[model$xcrop,model$ycrop])
      #chisq = (chi/Data$sigma)^2
      
      psfpad = padxy - dim(Data$image)
      nts = c()
      maxdivisions = ceiling(2*sqrt(padxy[1]))
      maxdivisions = 8
      for(nti in 2:maxdivisions)
      {
        denom = (padxy[1]+(nti-2)*psfpad[1])
        if(denom > 0 && ((denom %% nti) == 0)) nts = c(nts,nti)
      }
      nt = nts[length(nts)]
      
      incovar = Data$covarinv
      getcovar = is.null(incovar)
      if(getcovar) incovar = list(model$estvar, model$estcov)
      chisqcov = profitChisqFromEstDeconvCovErr(padimg, model$z, padsigma, 
        incovar, psf, nt, nt, skylevel/Data$gain)
      if(getcovar && Data$algo.func == "estcovar") 
      {
        outcovarinv = chisqcov$covarinvs
        outcovar = chisqcov$covars
      }
      model$z = model$z[model$xcrop,model$ycrop]
    }
    else
    {
      if(length(Data$calcregion) > 0 && all(is.finite(Data$calcregion)) && any(Data$calcregion)){
        model = profitMakeModel(model=paramsnew, magzero = Data$magzero, psf=Data$psf, dim=Data$imagedim, 
          serscomp=serscomp, psfcomp=psfcomp, rough=rough, calcregion=Data$calcregion, docalcregion=Data$usecalcregion,
          magmu=Data$magmu,finesample=finesample, convolve=Data$convolve)
      }else{
        model = profitMakeModel(model=paramsnew, magzero = Data$magzero, psf=Data$psf, dim=Data$imagedim, 
          serscomp=serscomp, psfcomp=psfcomp, rough=rough, magmu=Data$magmu, finesample=finesample, convolve=Data$convolve)
      }
    }
      
    if(makeplots){
      dofs = c()
      if(psfarea != 1) dofs = c(psfarea)
      if(usecovar)
      {
        profitMakePlots(img-skylevel,model$z-skylevel,Data$region, abs(chisqcov$chisqs), 
          errischisq = TRUE, cmap=cmap, errcmap=errcmap, dofs=dofs, plotchisq=TRUE)
      }
      else
      {
        profitMakePlots(img-skylevel,model$z-skylevel,Data$region, sigimg, cmap=cmap, errcmap=errcmap, 
           dofs=dofs,plotchisq=TRUE)
      }
    }
    if(Data$algo.func=="") return(list(model=model,psf=psf))
    model = model$z
    
    if(any(Data$region)) {
      cutim=img[Data$region]
      cutmod=model[Data$region]
      if(usecovar)
      {
        cutsig=chisqcov$chisqs[Data$region]
      } else {
        cutsig=sigimg[Data$region] 
      }
    } else {
      cutim=img
      cutmod=model
    }
    ndata = length(cutim)
    
    #dof/(dof-2)=var(data)
    #dof*(var(data)-1)=2*var(data)
    #dof=2*var(data)/(var(data)-1)
    if(usecovar)
    {
      vardata = var(sqrt(abs(cutsig)))
    } else {
      cutsig=(cutim-cutmod)/cutsig
      vardata = var(cutsig)
    }
    dof=2*vardata/(vardata-1)
    dof=interval(dof,0,Inf)
    if(usedt) {
      LL=sum(dt(cutsig,dof,log=TRUE))
    } else {
      LL = dchisq(sum(cutsig^2), ndata, log=TRUE)
    }
    
    LP=as.numeric(LL+priorsum)
    parm = unlist(parm)
    if(Data$verbose){print(c(parm,LP))}
    if(Data$algo.func == "estcovar") {out = list(LP = LP, LL=LL, covar=outcovar, covarinv=outcovarinv)}
    if(Data$algo.func=='optim' | Data$algo.func=='CMA'){out=LP}
    if(Data$algo.func=='LA' | Data$algo.func=='LD'){out=list(LP=LP,Dev=-2*LL,
      Monitor=c(LL=LL,LP=LP,dof=dof),yhat=1,parm=parm)}
    return(out)
}